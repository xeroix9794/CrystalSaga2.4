/* Generated by Together */

#ifndef GAMESERVERAPP_H
#define GAMESERVERAPP_H

#ifndef USE_IOCP

#include <string>
#include "DBCCommon.h"
#include "PreAlloc.h"
#include "ThreadPool.h"
#include "CommRPC.h"
#include "Point.h"
#include "Identity.h"
//#include "Usage.h"
#include "DataSocket.h"
#include "PacketQueue.h"
#include "Config.h"
#include "gtplayer.h"
#include "util.h"

#pragma pack( push, before_InfoNet )
#pragma pack( 8 )
#include "InfoNet.h"
#pragma pack( pop, before_InfoNet )

#include "MsgQueue.h"
using namespace dbc;
using namespace std;


// GateServer 描述结构
class GameServerApp;
class GateServer
{
public:
    GateServer() : m_pCDataSock(0), m_usPort(0), m_gtname(""), m_playerlist(NULL), m_playercount(0)
    {
    }

    ~GateServer()
    {
        m_pCDataSock = NULL;
        m_gtname = "";
    }

    void SetDataSock(DataSocket* datasock)
    {
        m_pCDataSock = datasock;
    }

    void Invalid()
    {
        m_pCDataSock = NULL;
    }

    bool IsValid() {return (m_pCDataSock != NULL) ? true : false;}

    string& GetIP() {return m_strIp;}
    unsigned short& GetPort() {return m_usPort;}
    string& GetName() {return m_gtname;}
    //GatePlayer*& GetPlayerList() {return m_playerlist;}
    DataSocket* GetDataSock() const {return m_pCDataSock;}

    long SendData(WPacket pkt)
    {
        if (IsValid()) 
		{
			if(m_pCDataSock)
				return m_pCDataSock->SendData(pkt);
			else
				return 0;
        } else {
            return 0;
        }        
    }

	GatePlayer* m_listcurplayer;	// 用于遍历链表

    // Player 双链表
    GatePlayer* m_playerlist;
	int m_playercount;
	void AddPlayerCount() {++ m_playercount;}
	void DecPlayerCount() {-- m_playercount;}
	int GetPlayerCount() const {return m_playercount;}

protected:
    string m_strIp;
    unsigned short m_usPort;
    string m_gtname;

    DataSocket* m_pCDataSock;

};


// 连接 GateServer 任务类
class ConnectGateServer : public Task
    {
public:
    ConnectGateServer(GameServerApp* gmsvr) {m_gmsvr = gmsvr; dwTimeOut = 3000;}

private:
    virtual long Process();
    DWORD dwTimeOut;
    GameServerApp* m_gmsvr;
};

// TradeServer消息队列
class NetMessageQueue : public MsgQueue<pNetMessage>
{
public:
    ~NetMessageQueue()
    {
        Clear();
    }

    void Clear()
    {
        deque<pNetMessage>::iterator it;

        m_lock.lock();
        for(it = m_queue.begin(); it != m_queue.end(); it++)
        {
            FreeNetMessage(*it);
        }
        m_queue.clear();
        m_lock.unlock();
    }
    
};

// TradeServer服务类
class TradeServer : public InfoNetBase
{
public:
    enum
    {
        CMD_FM_CONNECTED,       // 连上TradeServer
        CMD_FM_DISCONNECTED,    // 和TradeServer断开连接
        CMD_FM_MSG,             // TradeServer发来的消息

        CMD_INFO_MSG_MAX
    };
    
    TradeServer() : m_usPort(0), m_strIp(""), m_strPwd(""), bValid(false), m_nSection(0)
    {
    }

    ~TradeServer()
    {
    }

    bool IsValid() { return bValid; }
    void SetValid() { bValid = true; }
    void InValid() { bValid = false; }

    string GetIP() {return m_strIp;}
	string GetPwd() { return m_strPwd; }
    unsigned short GetPort() {return m_usPort;}
    void SetTradeServer(string strIP, unsigned short usPort, string strPwd, int nSection)
    {
        if(usPort)
        {
            m_strIp = strIP;
            m_usPort = usPort;
			m_strPwd = strPwd;
			m_nSection = nSection;
        }
    }

	void Login();

    //向TradeServer发送消息
    virtual bool SendData(pNetMessage msg)
    {
		bool bSend = false;
		msg->msgHead.msgSection = m_nSection;

		try
		{
			bSend = PostInfoSend(msg);
		}
		catch(...)
		{
			LG("Store_data", "SendData Error!\n");
		}

        return bSend;
    }

    //取消息队列
    virtual long PeekMsg(unsigned long ms);

    virtual void OnConnect(bool result);

    virtual void OnNetMessage(pNetMessage msg)
    {
        m_MsgQueue.Push(msg);
    }

    virtual void OnResend(pNetMessage msg)
    {
    }

    virtual void OnDisconnect();

protected:
    string m_strIp;
    unsigned short m_usPort;
	string m_strPwd;
	int m_nSection;
    bool bValid;
    NetMessageQueue m_MsgQueue;

};

// 监听 TradeServer 任务类
class ToTradeServer : public Task
{
public:
    ToTradeServer(GameServerApp* gmsvr) {m_gmsvr = gmsvr; m_dwTimeOut = 30000;}

private:
    virtual long Process();
    GameServerApp* m_gmsvr;
	DWORD m_dwTimeOut;
    
};

// Add by lark.li 20090112 begin
class ToMMS;
class ConnectMMS : public Task
{
public:
    ConnectMMS(ToMMS* tmms) {_tmms = tmms; _timeout = 3000;}
private:
    virtual long Process();
	virtual Task*Lastly();

    ToMMS* _tmms;
    DWORD _timeout;
};

class ToMMS : public TcpClientApp, public RPCMGR
{
    friend class ConnectMMS;
struct MMS
{
	MMS() : datasock(NULL) { }
    string ip; uShort port;
	string type;
	uShort key;

	DataSocket* datasock;
};

public:
    ToMMS(const char* configeName, ThreadPool* proc, ThreadPool* comm);
    ~ToMMS();

	int GetCallTotal() { return m_calltotal; }

	void EnterMap(int accountID, int charaterID, cChar* mapName);
	void LeaveMap(int accountID, int charaterID);

private:
    virtual bool OnConnect(DataSocket* datasock);
    virtual void OnDisconnect(DataSocket* datasock, int reason);
    virtual void OnProcessData(DataSocket* datasock, RPacket &recvbuf);
    virtual WPacket OnServeCall(DataSocket* datasock, RPacket &in_para);

	InterLockedLong	m_atexit,m_calltotal;
    bool volatile _connected;
	MMS	m_MMS;
};
// End

class CPlayer;
class UpdateDBCall :public PreAllocTask // 定时更细任务
{
public:
	UpdateDBCall(uLong size):PreAllocTask(size){};
	void Init(CPlayer	*pCPlayer){m_pCPlayer = pCPlayer;}
	long Process();

	CPlayer	*m_pCPlayer;
};

class GoOutServerCall :public PreAllocTask  // 登出GameServer
{
public:
	GoOutServerCall(uLong size):PreAllocTask(size){};
	void Init(CPlayer	*pCPlayer, bool	offLine){m_pCPlayer = pCPlayer; m_bOffLine = offLine;}
	long Process();

	CPlayer	*m_pCPlayer;
	bool	m_bOffLine;
};

class EnterServerCall :public PreAllocTask  // 登出GameServer
{
public:
	EnterServerCall(uLong size):PreAllocTask(size){};
	long Process();

	GateServer* pGate;
	uLong   l_actid;
	const char* pszPassword;
	uLong	l_dbid;
	uLong	l_worldid;
	cChar *	l_map;
	Long	lMapCpyNO;
	uLong	l_x;
	uLong	l_y;
	char	chLogin; // 角色上线(0)
	short	swiner;
	uLong	l_gtaddr;
};

// 网络通信应用类
class GameServerApp : public dbc::TcpClientApp, public dbc::RPCMGR, public PKQueue
    {
    friend class ConnectGateServer;
    friend class ToTradeServer;
    friend class TradeServer;

public:
	GameServerApp(dbc::ThreadPool *proc,dbc::ThreadPool *comm);
	virtual ~GameServerApp();

    // 登录相关
    char const* GetName() const {return m_strGameName.c_str();}
	void ConnectGate(GateServer *pGate);
    bool IsValidGate(int i);
    GateServer* FindGate(char const* gt_name);

    bool ConnectInfo(TradeServer *pInfo);
    void DisconnectInfo(TradeServer *pInfo);
    TradeServer *GetTradeServer() { return &m_IfServer; }

    // Player 相关 (GateServer内有GatePlayer的一个双链表)
    bool AddPlayer(GatePlayer* gtplayer, GateServer* gt, uLong gtaddr);
    bool DelPlayer(GatePlayer* gtplayer);
	// add by xuedong
	bool BeginGetplayer(GateServer* gt);
	GatePlayer* const GetNextPlayer(GateServer* gt);

	void BeginGetGate(void);
	GateServer* GetNextGate(void);
	//

    bool KickPlayer(GatePlayer* gtplayer, long lTimeSec = 0);
	bool KickPlayer2(GatePlayer *gtplayer);

    // 特定发包接口
    bool SendToWorld(WPacket& pkt);
	bool SendToGroup(WPacket& chginf);
    bool SendToClient(GatePlayer* player, WPacket& pkt);
    bool SendToClient(WPacket& pkt, GatePlayer* playerlist);
    bool SendToClient(WPacket& pkt, int array_cnt, uplayer* uplayer_array);
    bool SendToGame(WPacket& pkt, uplayer* uplyr);
    
protected:
	virtual bool OnConnect(dbc::DataSocket *datasock); //返回值:true-允许连接,false-不允许连接
	virtual void OnDisconnect(dbc::DataSocket *datasock,int reason); //reason值:0-本地程序正常退出；-3-网络被对方关闭；-1-Socket错误;-5-包长度超过限制.
	virtual void OnProcessData(dbc::DataSocket *datasock,dbc::RPacket &recvbuf);

	//virtual	bool	OnSendBlock(DataSocket *datasock){return true;}//返回值:true-允许继续等待,false-断开这个连接

	void ProcessData(DataSocket *datasock,RPacket &recvbuf);

    //处理TradeServer消息
    void ProcessData(pNetMessage msg, short sType);

public:	
	//long 				m_count;
	//dbc::DataSocket	*	m_groupsock;
	//Usage				m_usage;

	PreAllocHeap<UpdateDBCall>	m_UpdateProc;
	PreAllocHeap<GoOutServerCall>	m_GoOutProc;
	PreAllocHeap<EnterServerCall>	m_EnterProc;

private:
    Mutex m_mutdisconn;

    GateServer m_gtarray[MAX_GATE];
    short m_gtnum;
	short m_listcurgt;

    TradeServer m_IfServer;
	
    string m_strGameName;

	uLong	m_lastNetCheckTick;	// 网络包检查点
	uLong	m_netNum;			// 个数

	uLong	m_lastProcCheckTick;
	uLong	m_procNum;
};

inline bool GameServerApp::BeginGetplayer(GateServer* gt)
{
    if (gt == NULL) return false;
    if (!gt->IsValid()) return false;

	gt->m_listcurplayer = gt->m_playerlist;

	return true;
}

inline GatePlayer* const GameServerApp::GetNextPlayer(GateServer* gt)
{
	GatePlayer*	pretplayer = gt->m_listcurplayer;
	if (gt->m_listcurplayer)
		gt->m_listcurplayer = gt->m_listcurplayer->Next;

	return pretplayer;
}

inline void GameServerApp::BeginGetGate(void)
{
	m_listcurgt = 0;
}

inline GateServer* GameServerApp::GetNextGate(void)
{
	while (m_listcurgt < m_gtnum)
	{
	    if (m_gtarray[m_listcurgt++].IsValid())
			return m_gtarray + (m_listcurgt - 1);
	}

	return 0;
}

extern GameServerApp *g_gmsvr;

inline void uplayer::Init(char const* gt_name, unsigned long gt_addr, DWORD cha_id)
{
    pGate = g_gmsvr->FindGate(gt_name);
    m_dwDBChaId = cha_id;
    m_ulGateAddr = gt_addr;
}

#endif

#endif //GAMESERVERAPP_H
