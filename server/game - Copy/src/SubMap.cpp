/* Generated by Together */

#include "Stdafx.h"
#include "SubMap.h"
#include "MoveAble.h"
#include "GameApp.h"
#include "CommFunc.h"
#include "Parser.h"


_DBC_USING

const char* GetResPath(const char *pszRes);

SubMap::SubMap()
:m_pCEyeshotCell(0)
,m_pCStateCell(0)
,m_bIsRun(false)
{
	m_sCopyNO = 0;
	m_timeSpecialRun.Begin(300*1000);//5*60*1000

}

SubMap::~SubMap()
{
/*	for (short i = 0; i < GetEyeshotCellLin(); i++)
	{
		for (short j = 0; j < GetEyeshotCellCol(); j++)
		{
			delete [] m_pCEyeshotCell[i][j].m_pCStateCell;
		}
		delete [] m_pCEyeshotCell[i];
	}
	delete [] m_pCEyeshotCell;
	m_pCEyeshotCell = 0;

	for (short i = 0; i < GetStateCellLin(); i++)
		delete [] m_pCStateCell[i];
	delete [] m_pCStateCell;
	m_pCStateCell = 0;
*/
}

bool SubMap::Init(CMapRes *pCMapRes, dbc::Short sCopyNO)
{T_B
	m_pCMapRes = pCMapRes;
	m_pCBaseRange = 0;

	// 状态单元
	m_pCStateCell = new CStateCell**[GetStateCellLin()];
	if (!m_pCStateCell)
		//THROW_EXCP(excpMem,"地图状态单元对象构造过程中分配内存失败");
		THROW_EXCP(excpMem,RES_STRING(GM_SUBMAP_CPP_00001));
	for (short i = 0; i < GetStateCellLin(); i++)
	{
		m_pCStateCell[i] = new CStateCell*[GetStateCellCol()];
		if (!m_pCStateCell[i])
			//THROW_EXCP(excpMem,"地图状态单元对象构造过程中分配内存失败");
			THROW_EXCP(excpMem,RES_STRING(GM_SUBMAP_CPP_00001));
		for (short j = 0; j < GetStateCellCol(); j++)
			m_pCStateCell[i][j] = 0;
	}
	// 视野单元
	m_pCEyeshotCell = new CEyeshotCell*[GetEyeshotCellLin()];
	if (!m_pCEyeshotCell)
		//THROW_EXCP(excpMem,"地图视野单元对象构造过程中分配内存失败");
		THROW_EXCP(excpMem,RES_STRING(GM_SUBMAP_CPP_00002));
	short	sECellSX, sECellEX, sECellSY, sECellEY;
	short	sSCellNum;
	for (short i = 0; i < GetEyeshotCellLin(); i++)
	{
		m_pCEyeshotCell[i] = new CEyeshotCell[GetEyeshotCellCol()];
		if (!m_pCEyeshotCell[i])
			//THROW_EXCP(excpMem,"地图视野单元对象构造过程中分配内存失败");
			THROW_EXCP(excpMem,RES_STRING(GM_SUBMAP_CPP_00002));
		// 初始化
		for (short j = 0; j < GetEyeshotCellCol(); j++)
		{
			m_pCEyeshotCell[i][j].m_sPosX = j;
			m_pCEyeshotCell[i][j].m_sPosY = i;

			sECellSX = j * GetEyeshotCellWidth() / GetStateCellWidth();
			sECellEX = (j * GetEyeshotCellWidth() + GetEyeshotCellWidth() - 1) / GetStateCellWidth();
			sECellSY = i * GetEyeshotCellHeight() / GetStateCellHeight();
			sECellEY = (i * GetEyeshotCellHeight() + GetEyeshotCellHeight() - 1) / GetStateCellHeight();
			m_pCEyeshotCell[i][j].m_sStateCellNum = (sECellEX - sECellSX + 1) * (sECellEY - sECellSY + 1);
			m_pCEyeshotCell[i][j].m_pCStateCell = new CStateCell**[m_pCEyeshotCell[i][j].m_sStateCellNum];
			sSCellNum = 0;
			for (short m = sECellSY; m <= sECellEY; m++)
				for (short n = sECellSX; n <= sECellEX; n++)
					m_pCEyeshotCell[i][j].m_pCStateCell[sSCellNum++] = &m_pCStateCell[m][n];
		}
	}

	// 装载附加资源
	m_pCMapRes->m_pCMonsterSpawn->Load(this); // resok
	m_pCMapRes->m_pCMapSwitchEntitySpawn->Load(this); // resok
	LoadNpc(); // 注意NPC应该最后装载，必须在它装载前先初始化一些NPC需要的其他信息,resok
	LoadEventEntity(); // 装载事件实体信息,resok

	lua_dofile(g_pLuaState, GetResPath(m_pCMapRes->m_szMonsterCofFile)); //resok

	m_bIsRun = false;
	m_sCopyNO = sCopyNO;
	m_timeScriptRun.Begin(1000);
	m_lPlayerNum = 0;
//	m_lActivePlayerNum = 0;
	memset(m_lInfoParam, 0, sizeof(dbc::Long) * defMAPCOPY_INFO_PARAM_NUM);

	return true;
T_E}

//=============================================================================
// lFromEntityID 道具从该角色身上抛出来
// lProtChaID，lProtTime 对该角色保护时间，若lProtChaID为0，则不做保护.若lProtTime为0；则采用系统默认保护时间，为-1，则永久保护
// lOnTick 道具存在时间，为0，则采用系统默认保护时间；为-1，则永久存在
// usEventType，pEventRec 道具所带的事件
//=============================================================================
CItem* SubMap::ItemSpawn(const SItemGrid *pItemInfo, Long lPosX, Long lPosY, Char chSpawnType,
						 Long lFromEntityID, Long lProtChaID, Long lProtChaHandle, Long lProtTime, Long lOnTick,
						 CEvent	*pCEvent)
{T_B
	CItem *pCItem;
	CItemRecord *pCItemRec;

	pCItemRec = GetItemRecordInfo(pItemInfo->sID);
	if (!pCItemRec)
		return 0;
	pCItem = g_pGameApp->GetNewItem();
	if (!pCItem)
		return 0;
	memcpy(&pCItem->m_SGridContent, pItemInfo, sizeof(SItemGrid));
	//if (pCItemRec->chExclusiveID) // 需要保存到数据库，但当前的数据库ID是0，则需要分配
	//{
	//	pItemInfo->SetDBParam(-1, 0);
	//}
	//else
	//	pItemInfo->SetDBParam(-1, 0);
	pCItem->m_pCItemRecord = pCItemRec;
	if (pCEvent)
		pCItem->SetEvent(*pCEvent);
	pCItem->SetName(pCItemRec->szName);
	pCItem->SetCat(pItemInfo->sID);
	pCItem->m_ID = g_pGameApp->m_Ident.GetID();
	pCItem->SetSpawnType(chSpawnType);
	pCItem->SetFromID(lFromEntityID);
	Square SShape = {{lPosX, lPosY}, 0};
	pCItem->SetAngle(rand() / 360);
	pCItem->SetEyeshotAbility(false);
	if (!Enter(&SShape, pCItem))
	{
		pCItem->Free();
		return 0;
	}
	pCItem->SetSpawnType(enumITEM_APPE_NATURAL);
	pCItem->SetProtCha(lProtChaID, lProtChaHandle);
	if (lProtTime == -1)
		pCItem->SetProtOnTick(0);
	else if (lProtTime > 0)
		pCItem->SetProtOnTick(lProtTime);
	if (lOnTick == -1)
		pCItem->SetOnTick(0);
	if (lOnTick > 0)
		pCItem->SetOnTick(lOnTick);


	Char szLogName[defLOG_NAME_LEN] = "";
	//sprintf(szLogName, "%s+%u", pCItem->GetName(), pCItem->GetID());
	_snprintf_s(szLogName,sizeof(szLogName),_TRUNCATE, "%s+%u", pCItem->GetName(), pCItem->GetID());
	pCItem->m_CLog.SetLogName(szLogName);
	pCItem->m_CLog.SetEnable(g_bLogEntity);

	return pCItem;
T_E}

//=============================================================================
// chCtrlType 角色控制类型，参考CompCommand.h EChaCtrlType
//=============================================================================
CCharacter* SubMap::ChaSpawn(Long lChaInfoID, Char chCtrlType, Short sAngle, Point *pSPos, bool bEyeshotAbility, dbc::cChar *cszChaName, const long clSearchRadius)
{T_B
	CCharacter	*pCCha;
	CChaRecord	*pCChaRecord;

	if (!IsValidPos(pSPos->x, pSPos->y))
		return 0;

	pCChaRecord = GetChaRecordInfo(lChaInfoID);
	if (pCChaRecord == NULL)
		return 0;
	pCCha = g_pGameApp->GetNewCharacter();
	if (!pCCha)
		return 0;
	pCCha->m_CChaAttr.Init(lChaInfoID);
	if (chCtrlType == enumCHACTRL_NONE)
		chCtrlType = pCChaRecord->chCtrlType;
	pCCha->setAttr(ATTR_CHATYPE, chCtrlType);
	pCCha->m_pCChaRecord = pCChaRecord;
	pCCha->SetCat((short)(pCCha->m_pCChaRecord->lID));
	pCCha->SetID(g_pGameApp->m_Ident.GetID());
	pCCha->m_AIType = (BYTE)(pCChaRecord->lAiNo);
	pCCha->m_sChaseRange = (short)(pCChaRecord->lCDis);
	pCCha->SetAngle(sAngle);
	Square SShape = {*pSPos, pCCha->m_pCChaRecord->sRadii};
	if (!cszChaName)
		//strcpy(pCCha->m_name, pCCha->m_pCChaRecord->szName);
		strncpy_s( pCCha->m_name, sizeof(pCCha->m_name), pCCha->m_pCChaRecord->szName, _TRUNCATE );
	else
		//strcpy(pCCha->m_name, cszChaName);
		strncpy_s( pCCha->m_name, sizeof(pCCha->m_name), cszChaName, _TRUNCATE );
	pCCha->SetEyeshotAbility(bEyeshotAbility);
	if (pCChaRecord->sDormancy > 0)
		pCCha->SetExistState(enumEXISTS_SLEEPING);
	if (!Enter(&SShape, pCCha, clSearchRadius))
	{
		pCCha->Free();
		return 0;
	}
	Circle l_STerritory = {*pSPos, 500};
	pCCha->SetTerritory(l_STerritory);

	// 加入技能
	pCCha->EnrichSkillBag();

	Char szLogName[defLOG_NAME_LEN] = "";
	//sprintf(szLogName, "Cha-%s+%u", pCCha->GetName(), pCCha->GetID());
	_snprintf_s(szLogName,sizeof(szLogName),_TRUNCATE, "Cha-%s+%u", pCCha->GetName(), pCCha->GetID());
	pCCha->m_CLog.SetLogName(szLogName);
	pCCha->m_CLog.SetEnable(g_bLogEntity);

	// pCCha->ResetLifeTime(5000);
	
	return pCCha;
T_E}

// 通告副本内的所有玩家
void SubMap::Notice(const char *szString)
{T_B
	WPACKET WtPk  = GETWPACKET();
	WRITE_CMD(WtPk, CMD_MC_SYSINFO);
	WRITE_STRING(WtPk, szString);

	CPlayer	*pHeadPlayer = 0, *pLastPlayer = 0;
	CEyeshotCell	*pCEyeCell;
	CCharacter		*pCCha;
	Long			lChaCount, lChaNum;
	m_CEyeshotCellL.BeginGet();
	while (pCEyeCell = m_CEyeshotCellL.GetNext())
	{
		lChaCount = 0;
		lChaNum = pCEyeCell->GetChaNum();
		pCCha = pCEyeCell->m_pCChaL;
		while (pCCha)
		{
			if (++lChaCount > lChaNum)
			{
				//LG("视野激活错误", "视野单元[%d,%d]实际实体数 %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
				LG("eyeshot activation error", "eyeshot cell[%d,%d]fact entity nubmer%d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
				break;
			}

			if(pCCha->IsPlayerFocusCha())
			{
				if (!pHeadPlayer)
				{
					pHeadPlayer = pCCha->GetPlayer();
					pLastPlayer = pHeadPlayer;
				}
				else
				{
					pLastPlayer->GetNextPlayer() = pCCha->GetPlayer();
					pLastPlayer = (CPlayer *)pLastPlayer->GetNextPlayer();
				}

				if (!pCCha->GetSubMap())
					//LG("视野激活错误", "在进行地图通告时玩家 %s(%s)[%d,%d] 的地图为空\n",
					LG("eyeshot activation error", "in the wind map notify character %s(%s)[%d,%d] 's map is empty\n",
						pCCha->GetLogName(), pCCha->GetPlyCtrlCha()->GetLogName(), pCCha->GetPos().x, pCCha->GetPos().y);
			}

			if (pCCha->m_pCEyeshotCellNext)
				pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
			else
				pCCha = 0;
		}
	}

	if (pLastPlayer)
		pLastPlayer->GetNextPlayer() = NULL;
	SENDTOCLIENT(WtPk, pHeadPlayer);
T_E}

dbc::Long SubMap::CountEyeshotPlyActiveNum(dbc::Long lCellX, dbc::Long lCellY)
{T_B
	Long	lActNum = 0;

	CCharacter		*pCCha;
	Long			lChaCount = 0, lChaNum;
	pCCha = m_pCEyeshotCell[lCellY][lCellX].m_pCChaL;
	lChaNum = m_pCEyeshotCell[lCellY][lCellX].GetChaNum();
	while (pCCha)
	{
		if (++lChaCount > lChaNum)
		{
			//LG("视野激活错误", "计算视野单元[%d,%d]的激活角色数时，实际角色数 %d\n", lCellX, lCellY, lChaNum);
			LG("eyeshot activation error", "account eyeshot cell [%d,%d]'s activation character number，practice character number%d\n", lCellX, lCellY, lChaNum);
			break;
		}

		if(pCCha->IsPlayerCha())
		{
			if (pCCha->GetEyeshotAbility())
				lActNum++;
		}

		if (pCCha->m_pCEyeshotCellNext)
			pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
		else
			pCCha = 0;
	}

	return lActNum;
T_E}

// 检测位置是否可以通过
bool SubMap::IsMoveAble(Entity *pCEnt, Long lPosX, Long lPosY)
{T_B
	CFightAble	*pCCha = 0;
	if (!pCEnt || !(pCCha = pCEnt->IsFightAble()))
		return false;
	return g_IsMoveAble((char)pCCha->m_CChaAttr.GetAttr(ATTR_CHATYPE), pCCha->m_pCChaRecord->chTerritory, pCEnt->GetAreaAttr()); //存在障碍
T_E}

BOOL SubMap::LoadEventEntity()
{T_B
	g_pScriptMap = this;
	char szMapEntity[256];
	//sprintf( szMapEntity, "%s\\%s%s", GetName(), GetName(), "entity.lua" );
	_snprintf_s( szMapEntity,sizeof(szMapEntity),_TRUNCATE, "%s\\%s%s", GetName(), GetName(), "entity.lua" );
	ReloadEntity( GetResPath(szMapEntity) );
	return TRUE;
T_E}

BOOL SubMap::LoadNpc()
{T_B
	if( m_pCMapRes->m_pNpcSpawn->Load( *this ) == -1 )
	{
		//THROW_EXCP( excpMem, "初始化地图NPC出生信息错误!" );
		THROW_EXCP( excpMem, RES_STRING(GM_SUBMAP_CPP_00003) );
		return FALSE;
	}

	return TRUE;
T_E}

CNpcRecord* SubMap::GetNpcInfo( USHORT sNpcID )
{
	if( m_pCMapRes->m_pNpcSpawn )
	{
		return m_pCMapRes->m_pNpcSpawn->GetNpcInfo( sNpcID );
	}
	return NULL;
}

// 加入视野单元
void SubMap::Add(Entity* pCEnt)
{T_B
	CCharacter	*pCCha = pCEnt->IsCharacter();
	CItem		*pCItem;
	Point		l_pt = pCEnt->GetPos();
	Rect		l_rect = GetEyeshot(l_pt);

	if (pCEnt->m_pCEyeshotHost)
	{
		//LG("地图角色操作错误", "（切换）地图 %s 向视野单元[%d, %d]增加实体 %s 时，发现其没有脱离先前的视野单元[%d, %d]\n", GetName(), l_pt.x, l_pt.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
		LG("map character operator error", "(switch) map %s to eyeshot cell [%d, %d]add entity %s ，find it is not break away foregone manage cell[%d, %d]\n", GetName(), l_pt.x, l_pt.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
		return;
	}
	pCEnt->m_pCEyeshotHost = &m_pCEyeshotCell[l_pt.y][l_pt.x];

	if (pCCha)
	{
		if (pCCha->IsPlayerCha())
		{
			pCCha->GetPlayer()->RefreshMapMask(GetName(), pCCha->GetPos().x / 100, pCCha->GetPos().y / 100);
			pCCha->Cmd_SetInGymkhana(CanPK());
		}

		if (pCCha->IsPlayerOwnCha())
		{
			m_lPlayerNum++;
//			m_lActivePlayerNum++;
		}
	}

	if (pCCha)
	{
		m_pCEyeshotCell[l_pt.y][l_pt.x].AddEntity(pCCha);

		Long l_radius = pCEnt->GetRadius();
		l_pt = pCEnt->GetPos();
		Rect l_range = GetHoldStateCell(l_pt, l_radius);
		for (long i = l_range.ltop.y; i <= l_range.rbtm.y; i++)
			for (long j = l_range.ltop.x; j <= l_range.rbtm.x; j++)
			{
				if (i != l_pt.y || j != l_pt.x)
				{
					//StateCellAddCha(j, i, pCCha, false);
				}
				else
					StateCellAddCha(j, i, pCCha, true);
			}
	}
	else if (pCItem = pCEnt->IsItem())
	{
		m_pCEyeshotCell[l_pt.y][l_pt.x].AddEntity(pCItem);
	}

	if( pCCha)
	{
		pCCha->EntryMapUnit( GetMapID(), WORD(l_pt.x), WORD(l_pt.y) );
	}
T_E}

void SubMap::Delete(Entity* pCEnt)
{T_B
	CCharacter	*pCCha = pCEnt->IsCharacter();
	Point		l_pt = pCEnt->GetPos();
	//const Rect	&m_area = GetRange();
	//if (l_pt.x < m_area.ltop.x || l_pt.x >= m_area.rbtm.x || l_pt.y < m_area.ltop.y || l_pt.y >= m_area.rbtm.y)
	//{
	//	LG("地图角色操作错误", "（切换）从地图 %s 删除实体 %s 时，发现该实体的位置[%d, %d]非法\n", GetName(), pCEnt->GetLogName(), l_pt.x, l_pt.y);
	//	return;
	//}
	Rect		l_rect = GetEyeshot(l_pt);

	if (!pCEnt->m_pCEyeshotHost)
	{
		//LG("地图角色操作错误", "（切换）地图 %s 从视野单元[%d, %d]删除实体 %s 时，发现不在视野单元中\n", GetName(), l_pt.x, l_pt.y, pCEnt->GetLogName());
		LG("map character operator error", "(switch)map %s from eyeshot[%d, %d] delete entity %s ，find it isn't in eyeshot cell.\n", GetName(), l_pt.x, l_pt.y, pCEnt->GetLogName());
		return;
	}
	if (pCEnt->m_pCEyeshotHost != &m_pCEyeshotCell[l_pt.y][l_pt.x])
	{
		//LG("地图角色操作错误", "（切换）地图 %s 从视野单元[%d, %d]删除实体 %s 时，发现其与记录视野单元[%d, %d]不符\n", GetName(), l_pt.x, l_pt.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
		LG("map character operatot error", "(switch)map %s from eyeshot[%d, %d]delete entity %s，find it isn't agree with log eyeshot cell[%d, %d].\n", GetName(), l_pt.x, l_pt.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
		return;
	}
	pCEnt->m_pCEyeshotHost = 0;

	if (pCCha)
	{
		pCCha->Cmd_SetInGymkhana(false);

		if (pCCha->IsPlayerOwnCha())
		{
			m_lPlayerNum--;
			//if(pCCha->IsLiveing())
			//	m_lActivePlayerNum--;
		}
	}

	m_pCEyeshotCell[l_pt.y][l_pt.x].DelEntity(pCEnt);
	CStateCellNode	*pCNode = pCEnt->m_pCStateCellHead;
	if (pCCha)
	{
		while (pCNode)
		{
			StateCellDelCha(pCNode->m_pCStateCell->m_sPosX, pCNode->m_pCStateCell->m_sPosY, pCNode->m_pCChaNode);
			pCNode = pCNode->m_pCNext;
		}
	}
T_E}

// 脱离原状态单元，加入新的状态单元
void SubMap::MoveInStateCell(CCharacter* pCCha, const Point &SSrcPos, const Point &STarPos)
{T_B
	Point	l_src = SSrcPos;
	Point	l_dst = STarPos;
	Long	lRadius = pCCha->GetRadius();
	const Rect l_srcTerr = GetHoldStateCell(l_src, lRadius);
	const Rect l_dstTerr = GetHoldStateCell(l_dst, lRadius);

	if (l_src == l_dst)
		return;

	Long		x, y;
	// 从源范围删除
	CStateCellNode	*pCNode = pCCha->m_pCStateCellHead;
	if (pCCha)
	{
		while (pCNode)
		{
			StateCellDelCha(pCNode->m_pCStateCell->m_sPosX, pCNode->m_pCStateCell->m_sPosY, pCNode->m_pCChaNode);
			pCNode = pCNode->m_pCNext;
		}
	}
	// 向目标范围添加
	for (y = l_dstTerr.ltop.y; y <= l_dstTerr.rbtm.y; y++)
	{
		for (x = l_dstTerr.ltop.x; x <= l_dstTerr.rbtm.x; x++)
		{
			if (y != l_dst.y || x != l_dst.x)
			{
				//StateCellAddCha(x, y, pCCha, false); // 加入到其他管理单元
			}
			else
				StateCellAddCha(x, y, pCCha, true); // 加入到中心管理单元
		}
	}
T_E}

void SubMap::MoveInMapMask(CCharacter* pCCha, const Point &SSrcPos, const Point &STarPos)
{T_B
	if (!pCCha->IsPlayerCha())
		return;
	Point	l_src, l_dst;

	long	lStep = 4 * 100;
	l_src.x = SSrcPos.x / lStep;
	l_src.y = SSrcPos.y / lStep;
	l_dst.x = STarPos.x / lStep;
	l_dst.y = STarPos.y / lStep;
	if (l_src != l_dst)
		pCCha->GetPlayer()->RefreshMapMask(GetName(), STarPos.x / 100, STarPos.y / 100);
T_E}

//void SubMap::Move(Entity* pCEnt, Point STarPos, Char chStep)
//{
//	Point	l_src = pCEnt->GetPos();
//	Point	l_dst = STarPos;
//	Long	lRadius = pCEnt->GetRadius();
//	const Rect l_srcTerr = GetTerritory(l_src, lRadius);
//	const Rect l_dstTerr = GetTerritory(l_dst, lRadius);
//
//	Long		x, y;
//	if (chStep == 1) // 从源范围删除
//	{
//		//// log
//		//if (!strcmp("tty", pCEnt->GetName()))
//		//{
//		//	char	szPrint[512] = "";
//		//	LG("移动轨迹", "源  ：[%d,%d]--[%d,%d]，[%d,%d].\n",
//		//		l_srcTerr.ltop.x, l_srcTerr.ltop.y, l_srcTerr.rbtm.x, l_srcTerr.rbtm.y, l_src.x, l_src.y);
//		//	LG("移动轨迹", "目标：[%d,%d]--[%d,%d]，[%d,%d].\n",
//		//		l_dstTerr.ltop.x, l_dstTerr.ltop.y, l_dstTerr.rbtm.x, l_dstTerr.rbtm.y, l_dst.x, l_dst.y);
//
//		//	CMgrNode	*pCNode = pCEnt->m_pCMgrNodeHead;
//		//	while (pCNode)
//		//	{
//		//		sprintf(szPrint + strlen(szPrint), "[%d,%d],", pCNode->m_pCMgrUnit->m_sPosX, pCNode->m_pCMgrUnit->m_sPosY);
//		//		pCNode = pCNode->m_pCNext;
//		//	}
//		//	LG("移动轨迹", "角色占用的单元：%s.\n", szPrint);
//		//}
//		////
//
//		CMgrNode	*pCNode = pCEnt->m_pCMgrNodeHead, *pCTempNode;
//		if (pCNode) // 首节点
//		{
//			pCTempNode = pCNode->m_pCNext;
//
//			x = pCNode->m_pCMgrUnit->m_sPosX;
//			y = pCNode->m_pCMgrUnit->m_sPosY;
//			if (x < l_dstTerr.ltop.x || x > l_dstTerr.rbtm.x
//				|| y < l_dstTerr.ltop.y || y > l_dstTerr.rbtm.y) // 不在目标范围内
//				pCNode->m_pCMgrUnit->DelEntity(pCNode->m_pCEntityNode);
//			else
//			{
//				if (l_src != l_dst) // 原来是中心，现在不是
//					m_pCMgrUnit[y][x]->SetEntityIn(pCNode->m_pCEntityNode, false);
//			}
//
//			pCNode = pCTempNode;
//		}
//		while (pCNode)
//		{
//			pCTempNode = pCNode->m_pCNext;
//
//			x = pCNode->m_pCMgrUnit->m_sPosX;
//			y = pCNode->m_pCMgrUnit->m_sPosY;
//			if (x < l_dstTerr.ltop.x || x > l_dstTerr.rbtm.x
//				|| y < l_dstTerr.ltop.y || y > l_dstTerr.rbtm.y) // 不在目标范围内
//				pCNode->m_pCMgrUnit->DelEntity(pCNode->m_pCEntityNode);
//			else
//			{
//				if (l_src != l_dst)
//				{
//					if (l_dst.x == x && l_dst.y == y) // 原来不是中心，现在是
//						m_pCMgrUnit[y][x]->SetEntityIn(pCNode->m_pCEntityNode);
//				}
//			}
//
//			pCNode = pCTempNode;
//		}
//
//		//// log
//		//if (!strcmp("tty", pCEnt->GetName()))
//		//{
//		//	char	szPrint[512] = "";
//		//	CMgrNode	*pCNode = pCEnt->m_pCMgrNodeHead;
//		//	while (pCNode)
//		//	{
//		//		sprintf(szPrint + strlen(szPrint), "[%d,%d],", pCNode->m_pCMgrUnit->m_sPosX, pCNode->m_pCMgrUnit->m_sPosY);
//		//		pCNode = pCNode->m_pCNext;
//		//	}
//		//	LG("移动轨迹", "从源删除后，角色占用的单元：%s.\n", szPrint);
//
//		//	LG("移动轨迹", "源范围被删除后，拥有的角色：\n");
//		//	for (y = l_srcTerr.ltop.y; y <= l_srcTerr.rbtm.y; y++)
//		//		for (x = l_srcTerr.ltop.x; x <= l_srcTerr.rbtm.x; x++)
//		//		{
//		//			szPrint[0] = '\0';
//		//			CEntityListNode	*pCNode = m_pCMgrUnit[y][x]->m_pCChaIn;
//		//			while (pCNode)
//		//			{
//		//				sprintf(szPrint + strlen(szPrint), "%s,", pCNode->m_pCEntity->m_CLog.GetLogName());
//		//				pCNode = pCNode->m_pCNext;
//		//			}
//		//			LG("移动轨迹", "\t中心链[%d,%d]：%s\n", x, y, szPrint);
//		//			szPrint[0] = '\0';
//		//			pCNode = m_pCMgrUnit[y][x]->m_pCChaCross;
//		//			while (pCNode)
//		//			{
//		//				sprintf(szPrint + strlen(szPrint), "%s,", pCNode->m_pCEntity->m_CLog.GetLogName());
//		//				pCNode = pCNode->m_pCNext;
//		//			}
//		//			LG("移动轨迹", "\t交叉链[%d,%d]：%s\n", x, y, szPrint);
//		//		}
//		//}
//		////
//	}
//	else if (chStep == 2) // 向目标范围添加
//	{
//		pCEnt->SetPos(STarPos);
//		if (l_src != l_dst)
//			pCEnt->RefreshArea();
//		for (y = l_dstTerr.ltop.y; y <= l_dstTerr.rbtm.y; y++)
//		{
//			for (x = l_dstTerr.ltop.x; x <= l_dstTerr.rbtm.x; x++)
//			{
//				if (x < l_srcTerr.ltop.x || x > l_srcTerr.rbtm.x
//					|| y < l_srcTerr.ltop.y || y > l_srcTerr.rbtm.y) // 不在源范围内
//				{
//					if (y != l_dst.y || x != l_dst.x)
//						MgrUnitAddEntity(x, y, pCEnt, def_MGRUNIT_ENTITY_TYPE_CHACROSS); // 加入到其他管理单元
//					else
//						MgrUnitAddEntity(x, y, pCEnt, def_MGRUNIT_ENTITY_TYPE_CHAIN); // 加入到中心管理单元
//				}
//			}
//		}
//
//		//// log
//		//if (!strcmp("tty", pCEnt->GetName()))
//		//{
//		//	char	szPrint[512] = "";
//
//		//	CMgrNode	*pCNode = pCEnt->m_pCMgrNodeHead;
//		//	while (pCNode)
//		//	{
//		//		sprintf(szPrint + strlen(szPrint), "[%d,%d],", pCNode->m_pCMgrUnit->m_sPosX, pCNode->m_pCMgrUnit->m_sPosY);
//		//		pCNode = pCNode->m_pCNext;
//		//	}
//		//	LG("移动轨迹", "向目标添加后，角色占用的单元：%s.\n", szPrint);
//
//		//	LG("移动轨迹", "目标范围被添加后，拥有的角色：\n");
//		//	for (y = l_dstTerr.ltop.y; y <= l_dstTerr.rbtm.y; y++)
//		//		for (x = l_dstTerr.ltop.x; x <= l_dstTerr.rbtm.x; x++)
//		//		{
//		//			szPrint[0] = '\0';
//		//			CEntityListNode	*pCNode = m_pCMgrUnit[y][x]->m_pCChaIn;
//		//			while (pCNode)
//		//			{
//		//				sprintf(szPrint + strlen(szPrint), "%s,", pCNode->m_pCEntity->m_CLog.GetLogName());
//		//				pCNode = pCNode->m_pCNext;
//		//			}
//		//			LG("移动轨迹", "\t中心链[%d,%d]：%s\n", x, y, szPrint);
//		//			szPrint[0] = '\0';
//		//			pCNode = m_pCMgrUnit[y][x]->m_pCChaCross;
//		//			while (pCNode)
//		//			{
//		//				sprintf(szPrint + strlen(szPrint), "%s,", pCNode->m_pCEntity->m_CLog.GetLogName());
//		//				pCNode = pCNode->m_pCNext;
//		//			}
//		//			LG("移动轨迹", "\t交叉链[%d,%d]：%s\n", x, y, szPrint);
//		//		}
//		//	LG("移动轨迹", "\n");
//		//}
//		////
//	}
//}
//
//=============================================================================
// 进入副本（如果成功，则更新视野单元，进行视野通告）
// bActiveMgr 是否会激活管理单元
//=============================================================================
bool SubMap::Enter(Square* pSEntShape, Entity * ent, cLong clSearchRadius)
{T_B
	ent->SetInitShape(*pSEntShape);

	const	Point l_pt = pSEntShape->centre;
	bool	l_retval = true;
	Point	l_pt2, l_pt1;

	l_pt1 = l_pt;
	Rect	l_rect = GetEyeshot(l_pt1);
	long	lStep = pSEntShape->radius;

	if (lStep == 0) // 对于自身半径为0的情况
		lStep = 40;

	//确定初始位置
	ent->m_submap	=this;
	long l_xdlt	=0,l_ydlt	=0;
	
	if (clSearchRadius > 0)
	{
		if(ent->overlap(l_xdlt,l_ydlt))
		{
			long l_dist =0;
			bool l_overflag =true;
			while(l_overflag) //直到确定位置为止
			{
				l_dist++;
				for(short dir=0;dir<4;dir++){
					l_pt1	=l_pt;
					//long l_radius	=2 * lStep * l_dist;
					long l_radius	=GetBlockCellWidth() * l_dist;
					if(l_radius >clSearchRadius){
						l_retval	=false;
						l_overflag	=false;
						break;
					}
					l_pt1.move(dir*90,l_radius);
					l_pt2	=l_pt1;
					l_rect =GetEyeshot(l_pt2);

					ent->SetPos(l_pt1);
					l_xdlt	=l_ydlt		=0;

					if(!(l_overflag =ent->overlap(l_xdlt,l_ydlt))){
						l_retval	=true;
						break;
					}
				}
			}
		}
	}
	else if (clSearchRadius == 0)
	{
		if(ent->overlap(l_xdlt,l_ydlt))
			l_retval = false;
	}
	else // 强制进入
	{}
	//beginsee
	if(l_retval)
	{
		bool	bActive = ent->GetEyeshotAbility();

		for(long y =l_rect.ltop.y;y <=l_rect.rbtm.y;y++)
		{
			for(long x =l_rect.ltop.x;x <=l_rect.rbtm.x;x++)
			{
				if (bActive)
					ActiveEyeshotCell(x, y);

				m_pCEyeshotCell[y][x].EnterEyeshot(ent);
			}
		}

		//加入
		ent->RefreshArea();
		Add(ent);		
		ent->m_lastpos	=ent->GetPos();
	}
	else
		ent->m_submap = 0;


	return l_retval;
T_E}

// 模拟Enter例程，确定进入位置，但不执行进入副本操作
bool SubMap::EnsurePos(Square* pSEntShape, Entity * ent, cLong clSearchRadius)
{T_B
	ent->SetInitShape(*pSEntShape);

	const	Point l_pt = pSEntShape->centre;
	bool	l_retval = true;
	Point	l_pt2, l_pt1;

	l_pt1 = l_pt;
	long	lStep = pSEntShape->radius;

	if (lStep == 0) // 对于自身半径为0的情况
		lStep = 40;

	//确定初始位置
	ent->m_submap	=this;
	long l_xdlt	=0,l_ydlt	=0;
	
	if (clSearchRadius > 0)
	{
		if(ent->overlap(l_xdlt,l_ydlt))
		{
			long l_dist =0;
			bool l_overflag =true;
			while(l_overflag) //直到确定位置为止
			{
				l_dist++;
				for(short dir=0;dir<6;dir++){
					l_pt1	=l_pt;
					long l_radius	=2 * lStep * l_dist;
					if(l_radius >clSearchRadius){
						l_retval	=false;
						l_overflag	=false;
						break;
					}
					l_pt1.move(dir*60,l_radius);
					l_pt2	=l_pt1;

					ent->SetPos(l_pt1);
					l_xdlt	=l_ydlt		=0;

					if(!(l_overflag =ent->overlap(l_xdlt,l_ydlt))){
						l_retval	=true;
						break;
					}
				}
			}
		}
	}
	else if (clSearchRadius == 0)
	{
		if(ent->overlap(l_xdlt,l_ydlt))
			l_retval = false;
	}
	else // 强制进入
	{}
	//beginsee
	if(!l_retval)
		ent->m_submap = 0;


	return l_retval;
T_E}

//=============================================================================
// 出副本，脱离视野单元，进行视野通告
// bActiveMgr 是否对管理单元的计数产生影响
//=============================================================================
void SubMap::GoOut(Entity * ent)
{T_B
	Point l_pt =ent->GetShape().centre;
	Rect l_rect =GetEyeshot(l_pt);
	//删除
	Delete(ent);
	//endsee

	bool	bActive = ent->GetEyeshotAbility();

	for(long y =l_rect.ltop.y;y <=l_rect.rbtm.y;y++)
	{
		for(long x =l_rect.ltop.x;x <=l_rect.rbtm.x;x++)
		{
			if (bActive)
				InactiveEyeshotCell(x, y);

			m_pCEyeshotCell[y][x].OutEyeshot(ent);
		}
	}

	ent->m_submap =0;
T_E}

// 视野内的所有视野单元进行视野刷新
void SubMap::RefreshEyeshot(Entity *pCEnt, bool bEyeshot, bool bHide, bool bShow)
{
	Point l_pt = pCEnt->GetShape().centre;
	Rect l_rect = GetEyeshot(l_pt);

	for(long y =l_rect.ltop.y;y <=l_rect.rbtm.y;y++)
	{
		for(long x =l_rect.ltop.x;x <=l_rect.rbtm.x;x++)
		{
			m_pCEyeshotCell[y][x].RefreshEyeshot(pCEnt, bEyeshot, bHide, bShow);
		}
	}
}

Rect SubMap::GetEyeshot(Point &pt)const
{T_B
	const Rect	&m_area = GetRange();
	Rect l_rect;
	pt.x	=(pt.x - m_area.ltop.x)/GetEyeshotCellWidth();
	pt.y	=(pt.y - m_area.ltop.y)/GetEyeshotCellHeight();
	l_rect.ltop.x	=max(pt.x -GetEyeshotWidth(),0);
	l_rect.ltop.y	=max(pt.y -GetEyeshotWidth(),0);
	l_rect.rbtm.x	=min(pt.x +GetEyeshotWidth(),GetEyeshotCellCol() -1);
	l_rect.rbtm.y	=min(pt.y +GetEyeshotWidth(),GetEyeshotCellLin() -1);
	return l_rect;
T_E}

Rect SubMap::GetEyeshot(short sMgrUnitX, short sMgrUnitY)const
{T_B
	Rect	l_rect;

	l_rect.ltop.x = max(sMgrUnitX - GetEyeshotWidth(), 0);
	l_rect.ltop.y = max(sMgrUnitY - GetEyeshotWidth(), 0);
	l_rect.rbtm.x = min(sMgrUnitX + GetEyeshotWidth(), GetEyeshotCellCol() -1);
	l_rect.rbtm.y = min(sMgrUnitY + GetEyeshotWidth(), GetEyeshotCellLin() -1);

	return l_rect;
T_E}

void SubMap::GetEyeshotCenter(Point &pt)
{T_B
	const Rect	&m_area = GetRange();
	pt.x	=(pt.x - m_area.ltop.x) / GetEyeshotCellWidth();
	pt.y	=(pt.y - m_area.ltop.y) / GetEyeshotCellHeight();
T_E}

Rect SubMap::GetHoldStateCell(Point &pt, Long lRadius) const 
{T_B
	const Rect	&m_area = GetRange();
	Rect l_rect;
	if (lRadius > 0)
	{
		l_rect.ltop.x = (pt.x - lRadius - m_area.ltop.x) / GetStateCellWidth();
		l_rect.ltop.y = (pt.y - lRadius - m_area.ltop.y) / GetStateCellHeight();
		l_rect.rbtm.x = (pt.x + lRadius - m_area.ltop.x) / GetStateCellWidth();
		l_rect.rbtm.y = (pt.y + lRadius - m_area.ltop.x) / GetStateCellHeight();

		if (l_rect.ltop.x < 0) l_rect.ltop.x = 0;
		if (l_rect.rbtm.x >= GetStateCellCol()) l_rect.rbtm.x = GetStateCellCol() -1;
		if (l_rect.ltop.y < 0) l_rect.ltop.y = 0;
		if (l_rect.rbtm.y >= GetStateCellLin()) l_rect.rbtm.y = GetStateCellLin() -1;
	}
	else
	{
		l_rect.ltop.x = pt.x / GetStateCellWidth();
		l_rect.ltop.y = pt.y / GetStateCellHeight();
		l_rect.rbtm.x = pt.x / GetStateCellWidth();
		l_rect.rbtm.y = pt.y / GetStateCellHeight();
	}
	pt.x = (pt.x - m_area.ltop.x) / GetStateCellWidth();
	pt.y = (pt.y - m_area.ltop.y) / GetStateCellHeight();

	return l_rect;
T_E}

void SubMap::GetHoldStateCellCenter(Point &pt)
{
	const Rect	&m_area = GetRange();
	pt.x = (pt.x - m_area.ltop.x) / GetStateCellWidth();
	pt.y = (pt.y - m_area.ltop.y) / GetStateCellHeight();
}

//===============Search===================================================================================
CCharacter*	SubMap::FindCharacter( dbc::uLong ulID, const Point& point )
{T_B
	CCharacter* pCha = NULL;
	Long	lRangeB[] = {point.x, point.y, 0};
	Long	lRangeE[] = {enumRANGE_TYPE_CIRCLE, 10 * 100};
	BeginSearchInRange(lRangeB, lRangeE);
	while (pCha = GetNextCharacterInRange())
	{
		if(pCha->GetID() == ulID)
			break;
	}

	return pCha;
T_E}

//=============================================================================
// plRangeBParam 区域基本参数：个数 defSKILL_RANGE_BASEP_NUM， 内容 区域中心坐标，方向
// plRangeEParam 区域扩展参数：个数 defSKILL_RANGE_EXTEP_NUM， 内容 范围类型，类型参数
// bIncludeHideEnti 是否包含隐身的实体
//=============================================================================
void SubMap::BeginSearchInRange(Long *plRangeBParam, Long *plRangeEParam, bool bIncludeHideEnti)
{T_B
    m_sRangeCurMgrUnit = -1;
	m_pRangeCurEntiNode = 0;
	m_bIncludeHideEnti = bIncludeHideEnti;

	Long	lCx = plRangeBParam[0];
	Long	lCy = plRangeBParam[1];
	Long	lAngle = plRangeBParam[2];
	Long	lRangeType = plRangeEParam[0];

	Long	lUnitSX, lUnitEX, lUnitSY, lUnitEY;
	Long	lMaxRadius;
	if (lRangeType == enumRANGE_TYPE_STICK)
	{
		Long	lRadius = plRangeEParam[1];
		Long	lWidth = plRangeEParam[2];

		m_pCBaseRange = &m_CStickRange;
		m_CStickRange.setPos(lCx, lCy);
		m_CStickRange.setAngle(lAngle);
		m_CStickRange.setRadius(lRadius);
		m_CStickRange.setWidth(lWidth);

		lMaxRadius = (Long)sqrt(double(lRadius * lRadius + (lWidth / 2) * (lWidth / 2)));
	}
	else if (lRangeType == enumRANGE_TYPE_FAN)
	{
		Long	lRadius = plRangeEParam[1];
		Long	lAngleD = plRangeEParam[2];

		m_pCBaseRange = &m_CFanRange;
		m_CFanRange.setPos(lCx, lCy);
		lAngle = lAngle - lAngleD / 2;
		if (lAngle < 0)
			lAngle += 360;
		m_CFanRange.setAngle(lAngle);
		m_CFanRange.setAngleStep(lAngleD);
		m_CFanRange.setRadius(lRadius);

		lMaxRadius = lRadius;
	}
	else if (lRangeType == enumRANGE_TYPE_SQUARE)
	{
		Long	lRadius = plRangeEParam[1];

		m_pCBaseRange = &m_CSquareCRange;
		m_CSquareCRange.setPos(lCx, lCy);
		m_CSquareCRange.setAngle(lAngle);
		m_CSquareCRange.setRadius(lRadius);

		lMaxRadius = lRadius;
	}
	else if (lRangeType == enumRANGE_TYPE_CIRCLE)
	{
		Long	lRadius = plRangeEParam[1];

		m_pCBaseRange = &m_CCircleRange;
		m_CCircleRange.setPos(lCx, lCy);
		m_CCircleRange.setRadius(lRadius);

		lMaxRadius = lRadius;
	}
	else
		m_pCBaseRange = 0;

	if (!m_pCBaseRange)
		return;

	m_lRangeCentUnit[0] = lCx / GetStateCellWidth();
	m_lRangeCentUnit[1] = lCy / GetStateCellHeight();

	lUnitSX = (lCx - lMaxRadius) / GetStateCellWidth();
	lUnitEX = (lCx + lMaxRadius) / GetStateCellWidth();
	lUnitSY = (lCy - lMaxRadius) / GetStateCellHeight();
	lUnitEY = (lCy + lMaxRadius) / GetStateCellHeight();
	lUnitSX = lUnitSX < 0 ? 0 : lUnitSX;
	lUnitEX = lUnitEX > GetStateCellCol() -1 ? GetStateCellCol() -1 : lUnitEX;
	lUnitSY = lUnitSY < 0 ? 0 : lUnitSY;
	lUnitEY = lUnitEY > GetStateCellLin() -1 ? GetStateCellLin() -1 : lUnitEY;

	m_sRangeMgrUnitNum = 0;
	Long	sx, sy, ex, ey;
	for (int i = lUnitSY; i <= lUnitEY; i++)
		for (int j = lUnitSX; j <= lUnitEX; j++)
		{
			sx = j * GetStateCellWidth();
			ex = sx + GetStateCellWidth() - 1;
			sy = i * GetStateCellHeight();
			ey = sy + GetStateCellHeight() - 1;
			if (m_pCBaseRange->RectHitTest(sx, sy, ex, ey)) // 管理单元在范围内
			{
				m_lRangeMgrUnit[m_sRangeMgrUnitNum][0] = j;
				m_lRangeMgrUnit[m_sRangeMgrUnitNum][1] = i;
				m_sRangeMgrUnitNum++;
				if (m_sRangeMgrUnitNum >= defRANGE_MGRUNIU_NUM)
				{
					//MessageBox(NULL, "区域搜索的范围超过设定值", "错误", MB_OK);
					MessageBox(NULL, RES_STRING(GM_SUBMAP_CPP_00004), RES_STRING(GM_SUBMAP_CPP_00005), MB_OK);
					return;
				}
			}
		}
T_E}

CCharacter* SubMap::GetNextCharacterInRange(void)
{T_B
	if (!m_pCBaseRange)
		return 0;

Research:
	if (m_pRangeCurEntiNode)
		m_pRangeCurEntiNode = m_pRangeCurEntiNode->m_pCNext;

	while (!m_pRangeCurEntiNode)
	{
		m_sRangeCurMgrUnit++;
		if (m_sRangeCurMgrUnit >= m_sRangeMgrUnitNum)
			return 0;
		if (m_pCStateCell[m_lRangeMgrUnit[m_sRangeCurMgrUnit][1]][m_lRangeMgrUnit[m_sRangeCurMgrUnit][0]])
			m_pRangeCurEntiNode = m_pCStateCell[m_lRangeMgrUnit[m_sRangeCurMgrUnit][1]][m_lRangeMgrUnit[m_sRangeCurMgrUnit][0]]->m_pCChaIn;
	}

	if (m_pRangeCurEntiNode)
	{
		if (!m_bIncludeHideEnti)
		{
			CCharacter	*pCCha = m_pRangeCurEntiNode->m_pCCha;
			if (pCCha && pCCha->IsHide())
				goto Research;
			else
				return pCCha;
		}
		else
			return m_pRangeCurEntiNode->m_pCCha;
	}
	else
		return 0;
T_E}

//=============================================================================
// 在例程BeginSearchInRange设定的范围内增加状态
//=============================================================================
bool SubMap::RangeAddState(uChar uchFightID, uLong ulSrcWorldID, Long lSrcHandle,
						   Char chObjType, Char chObjHabitat, Char chEffType, Short *sStateParam)
{T_B
	if (sStateParam[0] > AREA_STATE_MAXID || sStateParam[1] > SKILL_STATE_LEVEL)
		return false;

	if (!m_pCBaseRange)
		return false;

	CSkillStateRecord	*pSStateR = 0;
	pSStateR = GetCSkillStateRecordInfo(sStateParam[0]);
	if (!pSStateR)
		return false;

	Long	x, y;
	uLong	ulStartTick = GetTickCount();
	bool	bAddSuc;
	bool	bAlreadyHas;
	for (Short i = 0; i < m_sRangeMgrUnitNum; i++)
	{
		bAddSuc = false;
		bAlreadyHas = false;
		x = m_lRangeMgrUnit[i][0], y = m_lRangeMgrUnit[i][1];

		if (m_pCStateCell[y][x] && m_pCStateCell[y][x]->m_CSkillState.HasState((uChar)sStateParam[0]))
			bAlreadyHas = true;
		if (x == m_lRangeCentUnit[0] && y == m_lRangeCentUnit[1])
			bAddSuc = AddCellState(uchFightID, ulSrcWorldID, lSrcHandle, chObjType, chObjHabitat, chEffType, x, y, (uChar)sStateParam[0], (uChar)sStateParam[1], ulStartTick, sStateParam[2], pSStateR->chAddType, 1);
		else
			bAddSuc = AddCellState(uchFightID, ulSrcWorldID, lSrcHandle, chObjType, chObjHabitat, chEffType, x, y, (uChar)sStateParam[0], (uChar)sStateParam[1], ulStartTick, sStateParam[2], pSStateR->chAddType, 0);
		if (!bAlreadyHas && bAddSuc)
		{
			NotiStateCellToEyeshot((short)x, (short)y);
		}
	}

	return true;
T_E}

bool SubMap::RangeAddState(Rect *pSRange, uChar uchFightID, uLong ulSrcWorldID, Long lSrcHandle,
						   Char chObjType, Char chObjHabitat, Char chEffType, Short *sStateParam)
{T_B
	if (sStateParam[0] > AREA_STATE_MAXID || sStateParam[1] > SKILL_STATE_LEVEL)
		return false;

	CSkillStateRecord	*pSStateR = 0;
	pSStateR = GetCSkillStateRecordInfo(sStateParam[0]);
	if (!pSStateR)
		return false;

	Long	lUnitSX, lUnitEX, lUnitSY, lUnitEY, lUnitCX, lUnitCY;
	lUnitSX = pSRange->ltop.x / GetStateCellWidth();
	lUnitEX = pSRange->rbtm.x / GetStateCellWidth();
	lUnitSY = pSRange->ltop.y / GetStateCellHeight();
	lUnitEY = pSRange->rbtm.y / GetStateCellHeight();
	lUnitSX = lUnitSX < 0 ? 0 : lUnitSX;
	lUnitEX = lUnitEX > GetStateCellCol() -1 ? GetStateCellCol() -1 : lUnitEX;
	lUnitSY = lUnitSY < 0 ? 0 : lUnitSY;
	lUnitEY = lUnitEY > GetStateCellLin() -1 ? GetStateCellLin() -1 : lUnitEY;

	lUnitCX = lUnitSX + (lUnitEX - lUnitSX) / 2;
	lUnitCY = lUnitSY + (lUnitEY - lUnitSY) / 2;

	uLong	ulStartTick = GetTickCount();
	bool	bAddSuc;
	bool	bAlreadyHas;
	for (Long y = lUnitSY; y <= lUnitEY; y++)
		for (Long x = lUnitSX; x <= lUnitEX; x++)
		{
			bAddSuc = false;
			bAlreadyHas = false;

			if (m_pCStateCell[y][x] && m_pCStateCell[y][x]->m_CSkillState.HasState((uChar)sStateParam[0]))
				bAlreadyHas = true;
			if (y == lUnitCY && x == lUnitCX)
				bAddSuc = AddCellState(uchFightID, ulSrcWorldID, lSrcHandle, chObjType, chObjHabitat, chEffType, x, y, (uChar)sStateParam[0], (uChar)sStateParam[1], ulStartTick, sStateParam[2], pSStateR->chAddType, 1);
			else
				bAddSuc = AddCellState(uchFightID, ulSrcWorldID, lSrcHandle, chObjType, chObjHabitat, chEffType, x, y, (uChar)sStateParam[0], (uChar)sStateParam[1], ulStartTick, sStateParam[2], pSStateR->chAddType, 0);
			if (!bAlreadyHas && bAddSuc)
			{
				ActiveEyeshotCell(m_pCStateCell[y][x]->m_pCEyeshotCell->m_sPosX, m_pCStateCell[y][x]->m_pCEyeshotCell->m_sPosY); // 状态激活管理单元
				NotiStateCellToEyeshot((short)x, (short)y);
			}
		}

	return true;
T_E}

void SubMap::NotiStateCellToEyeshot(Short sCellX, Short sCellY)
{T_B
	if (!m_pCStateCell[sCellY][sCellX])
		return;

	WPACKET pk	=GETWPACKET();
	WRITE_CMD(pk, CMD_MC_ASTATEBEGINSEE);
	WRITE_SHORT(pk, sCellX);
	WRITE_SHORT(pk, sCellY);
	m_pCStateCell[sCellY][sCellX]->m_CSkillState.WriteState(pk);

	Rect	l_rect = GetEyeshot(m_pCStateCell[sCellY][sCellX]->m_pCEyeshotCell->m_sPosX, m_pCStateCell[sCellY][sCellX]->m_pCEyeshotCell->m_sPosY);
	Entity		*pCEnt;
	CCharacter	*pCCha;
	CPlayer	*pHeadPlayer = 0, *pLastPlayer = 0;
	for (long y = l_rect.ltop.y; y <= l_rect.rbtm.y; y++)
	{
		for (long x = l_rect.ltop.x; x <= l_rect.rbtm.x; x++)
		{
			pCEnt = m_pCEyeshotCell[y][x].m_pCChaL;
			while (pCEnt)
			{
				pCCha = pCEnt->IsCharacter();
				if(pCCha->IsPlayerFocusCha())
				{
					if (!pHeadPlayer)
					{
						pHeadPlayer = pCCha->GetPlayer();
						pLastPlayer = pHeadPlayer;
					}
					else
					{
						pLastPlayer->GetNextPlayer() = pCCha->GetPlayer();
						pLastPlayer = (CPlayer *)pLastPlayer->GetNextPlayer();
					}
				}
				pCEnt = pCEnt->m_pCEyeshotCellNext;
			}
		}
	}
	if (pLastPlayer)
		pLastPlayer->GetNextPlayer() = NULL;
	SENDTOCLIENT(pk, pHeadPlayer);
T_E}

//=============================================================================
// 移动（移动位置，视野）
//=============================================================================
void SubMap::MoveTo(Entity *pCEnt, const Point &STar)
{T_B
	if (pCEnt->GetPos() != pCEnt->m_lastpos)
	{
		Char	szMess[512];
		//sprintf(szMess, "角色 %s 移动原始坐标错误，上次位置[%d, %d]，当前位置[%d, %d]，目标位置[%d, %d]",
		//sprintf(szMess, "character %s move originality coordinate error，last time position[%d, %d]，current position[%d, %d]，aim position[%d, %d]",
		//	pCEnt->m_CLog.GetLogName(), pCEnt->m_lastpos.x, pCEnt->m_lastpos.y, pCEnt->GetPos().x, pCEnt->GetPos().y, STar.x, STar.y);
		_snprintf_s(szMess,sizeof(szMess),_TRUNCATE,"character %s move originality coordinate error，last time position[%d, %d]，current position[%d, %d]，aim position[%d, %d]",
			pCEnt->m_CLog.GetLogName(), pCEnt->m_lastpos.x, pCEnt->m_lastpos.y, pCEnt->GetPos().x, pCEnt->GetPos().y, STar.x, STar.y);

		//::MessageBox(0,szMess,"请调试!",MB_OK);
		//LG("移动错误", "%s\n", szMess);
		LG("move error", "%s\n", szMess);
		pCEnt->SetPos(pCEnt->m_lastpos);
	}
	Point	l_src = pCEnt->GetPos();
	Point	l_dst = STar;
	Point	SrcPos = l_src;
	const Rect l_srcEyeshot = GetEyeshot(l_src);
	const Rect l_dstEyeshot = GetEyeshot(l_dst);

	LETimer tMoveState, tMoveMMask, tMoveEyeshot, tMoveArea;
	tMoveState.Begin();
	MoveInStateCell(pCEnt->IsCharacter(), pCEnt->GetPos(), STar);
	tMoveState.End();
	tMoveMMask.Begin();
	MoveInMapMask(pCEnt->IsCharacter(), pCEnt->GetPos(), STar);
	tMoveMMask.End();
	tMoveEyeshot.Begin();
	pCEnt->SetPos(STar);
	if (l_src != l_dst) // 视角不重叠
	{
		//从源删除
		if (!pCEnt->m_pCEyeshotHost)
		{
			//LG("地图角色操作错误", "（移动）地图 %s 从视野单元[%d, %d]删除实体 %s 时，发现不在视野单元中\n", GetName(), l_src.x, l_src.y, pCEnt->GetLogName());
			LG("map character operator error", "(move)map  %s from eyeshot cell[%d, %d]delete entity %s ，find it isn't in the eyeshot cell.\n", GetName(), l_src.x, l_src.y, pCEnt->GetLogName());
			return;
		}
		if (pCEnt->m_pCEyeshotHost != &m_pCEyeshotCell[l_src.y][l_src.x])
		{
			//LG("地图角色操作错误", "（移动）地图 %s 从视野单元[%d, %d]删除实体 %s 时，发现其与记录视野单元[%d, %d]不符\n", GetName(), l_src.x, l_src.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
			LG("map character operator error", "(move)map %s from eyeshot cell[%d, %d]delete entity %s ,find it isn't agree with log eyeshot cell[%d, %d].\n", GetName(), l_src.x, l_src.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
			return;
		}
		pCEnt->m_pCEyeshotHost = 0;
		m_pCEyeshotCell[l_src.y][l_src.x].DelEntity(pCEnt);

		bool	bActive = pCEnt->GetEyeshotAbility();

		////beginsee and endsee
		//long	lXDist, lYDist, lXStep, lYStep, lSrcXStart, lTarXStart, lSrcYStart, lTarYStart;
		//lXDist = abs(l_src.x - l_dst.x);
		//if (lXDist > GetEyeshotWidth() * 2 + 1)
		//	lXDist = GetEyeshotWidth() * 2 + 1;
		//if (lXDist > 0)
		//{
		//	if (l_src.x >= l_dst.x)
		//	{
		//		if (l_srcEyeshot.rbtm.x == GetEyeshotCellCol() - 1)
		//			lSrcXStart = l_src.x + GetEyeshotWidth() - lXDist + 1;
		//		else
		//			lSrcXStart = l_srcEyeshot.rbtm.x - lXDist + 1;
		//		if (l_dstEyeshot.ltop.x == 0)
		//			lTarXStart = l_dst.x - GetEyeshotWidth();
		//		else
		//			lTarXStart = l_dstEyeshot.ltop.x;
		//	}
		//	else
		//	{
		//		if (l_srcEyeshot.ltop.x == 0)
		//			lSrcXStart = l_src.x - GetEyeshotWidth();
		//		else
		//			lSrcXStart = l_srcEyeshot.ltop.x;
		//		if (l_dstEyeshot.rbtm.x == GetEyeshotCellCol() - 1)
		//			lTarXStart = l_dst.x + GetEyeshotWidth() - lXDist + 1;
		//		else
		//			lTarXStart = l_dstEyeshot.rbtm.x - lXDist + 1;
		//	}

		//	for (long x = 0; x < lXDist; x++)
		//	{
		//		lXStep = lSrcXStart + x;
		//		if ((lXStep >= 0) && (lXStep <= GetEyeshotCellCol() - 1))
		//		{
		//			for (long y = l_srcEyeshot.ltop.y; y <= l_srcEyeshot.rbtm.y; y++)
		//			{
		//				if (bActive)
		//					InactiveEyeshotCell(lXStep, y);
		//				m_pCEyeshotCell[y][lXStep].OutEyeshot(pCEnt);
		//			}
		//		}
		//		lXStep = lTarXStart + x;
		//		if ((lXStep >= 0) && (lXStep <= GetEyeshotCellCol() - 1))
		//		{
		//			for (long y = l_dstEyeshot.ltop.y; y <= l_dstEyeshot.rbtm.y; y++)
		//			{
		//				if (bActive)
		//					ActiveEyeshotCell(lXStep, y);
		//				m_pCEyeshotCell[y][lXStep].EnterEyeshot(pCEnt);
		//			}
		//		}
		//	}
		//}

		//lXDist = abs(l_src.x - l_dst.x);
		//lYDist = abs(l_src.y - l_dst.y);
		//if ((lYDist > 0) && (lXDist < GetEyeshotWidth() * 2 + 1))
		//{
		//	lXDist = GetEyeshotWidth() * 2 + 1 - lXDist;
		//	if (l_src.x >= l_dst.x)
		//	{
		//		if (l_srcEyeshot.ltop.x == 0)
		//		{
		//			lSrcXStart = 0;
		//			lXDist += l_src.x - GetEyeshotWidth();
		//		}
		//		else
		//			lSrcXStart = l_srcEyeshot.ltop.x;
		//	}
		//	else
		//	{
		//		if (l_dstEyeshot.ltop.x == 0)
		//		{
		//			lSrcXStart = 0;
		//			lXDist += l_dst.x - GetEyeshotWidth();
		//		}
		//		else
		//			lSrcXStart = l_dstEyeshot.ltop.x;
		//	}
		//	if (lYDist > GetEyeshotWidth() * 2 + 1)
		//		lYDist = GetEyeshotWidth() * 2 + 1;
		//	if (l_src.y >= l_dst.y)
		//	{
		//		if (l_srcEyeshot.rbtm.y == GetEyeshotCellLin() - 1)
		//			lSrcYStart = l_src.y + GetEyeshotWidth() - lYDist + 1;
		//		else
		//			lSrcYStart = l_srcEyeshot.rbtm.y - lYDist + 1;
		//		if (l_dstEyeshot.ltop.y == 0)
		//			lTarYStart = l_dst.y - GetEyeshotWidth();
		//		else
		//			lTarYStart = l_dstEyeshot.ltop.y;
		//	}
		//	else
		//	{
		//		if (l_srcEyeshot.ltop.y == 0)
		//			lSrcYStart = l_src.y - GetEyeshotWidth();
		//		else
		//			lSrcYStart = l_srcEyeshot.ltop.y;
		//		if (l_dstEyeshot.rbtm.y == GetEyeshotCellLin() - 1)
		//			lTarYStart = l_dst.y + GetEyeshotWidth() - lYDist + 1;
		//		else
		//			lTarYStart = l_dstEyeshot.rbtm.y - lYDist + 1;
		//	}
		//	for (long x = 0; x < lXDist; x++)
		//	{
		//		lXStep = lSrcXStart + x;
		//		for (long y = 0; y < lYDist; y++)
		//		{
		//			lYStep = lSrcYStart + y;
		//			if ((lYStep >= 0) && (lYStep <= GetEyeshotCellLin() - 1))
		//			{
		//				if (bActive)
		//					InactiveEyeshotCell(lXStep, lYStep);
		//				m_pCEyeshotCell[lYStep][lXStep].OutEyeshot(pCEnt);
		//			}

		//			lYStep = lTarYStart + y;
		//			if ((lYStep >= 0) && (lYStep <= GetEyeshotCellLin() - 1))
		//			{
		//				if (bActive)
		//					ActiveEyeshotCell(lXStep, lYStep);
		//				m_pCEyeshotCell[lYStep][lXStep].EnterEyeshot(pCEnt);
		//			}
		//		}
		//	}
		//}

		const long l_xmin = min(l_srcEyeshot.ltop.x, l_dstEyeshot.ltop.x);
		const long l_xmax = max(l_srcEyeshot.rbtm.x, l_dstEyeshot.rbtm.x);
		const long l_ymin = min(l_srcEyeshot.ltop.y, l_dstEyeshot.ltop.y);
		const long l_ymax = max(l_srcEyeshot.rbtm.y, l_dstEyeshot.rbtm.y);
		for (long y = l_ymin; y <= l_ymax; y++)
		{
			for(long x = l_xmin; x <= l_xmax; x++)
			{
				const long l_srcx = abs(x - l_src.x);
				const long l_srcy = abs(y - l_src.y);
				const long l_dstx = abs(x - l_dst.x);
				const long l_dsty = abs(y - l_dst.y);
				if (l_srcx <= GetEyeshotWidth() && l_srcy <= GetEyeshotWidth()
					&& l_dstx <= GetEyeshotWidth() && l_dsty <= GetEyeshotWidth()) //相交区域
					continue;
				else if ((l_srcx > GetEyeshotWidth() || l_srcy > GetEyeshotWidth())
					&& (l_dstx > GetEyeshotWidth() || l_dsty > GetEyeshotWidth())) //无关区域
					continue;
				else if (abs(x - l_src.x) <= GetEyeshotWidth() && abs(y - l_src.y) <= GetEyeshotWidth()) //源块附近的，endsee
				{
					if (bActive)
						InactiveEyeshotCell(x, y);
					m_pCEyeshotCell[y][x].OutEyeshot(pCEnt);
				}
				else		//目标块附近的，beginsee
				{
					if (bActive)
						ActiveEyeshotCell(x, y);
					m_pCEyeshotCell[y][x].EnterEyeshot(pCEnt);
				}
			}
		}

		//插入目标
		if (pCEnt->m_pCEyeshotHost)
		{
			//LG("地图角色操作错误", "（移动）地图 %s 向视野单元[%d, %d]增加实体 %s 时，发现其没有脱离先前的视野单元[%d, %d]\n", GetName(), l_dst.x, l_dst.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
			LG("map character operator error", "(move)map %s from eyeshot cell[%d, %d] add entity %s ，find it is not break away foregone manage cell[%d, %d]\n", GetName(), l_dst.x, l_dst.y, pCEnt->GetLogName(), pCEnt->m_pCEyeshotHost->m_sPosX, pCEnt->m_pCEyeshotHost->m_sPosY);
			return;
		}
		pCEnt->m_pCEyeshotHost = &m_pCEyeshotCell[l_dst.y][l_dst.x];
		m_pCEyeshotCell[l_dst.y][l_dst.x].AddEntity(pCEnt->IsCharacter());
	}
	tMoveEyeshot.End();

	tMoveArea.Begin();
	pCEnt->RefreshArea(&SrcPos);
	pCEnt->m_lastpos = STar;
	tMoveArea.End();

	DWORD	dwAllTime = tMoveState.GetTimeCount() + tMoveMMask.GetTimeCount() + tMoveEyeshot.GetTimeCount() + tMoveArea.GetTimeCount();
	if (dwAllTime >= 50)
		//LG("map_time", "\t\t角色[%s]视野移动花费的时间过长 time = %u（其中状态花费%u，探索度花费%u，视野花费%u，区域花费%u）\n",
		LG("map_time", "\t\tcharacter[%s] eyeshot move spend overabundance time time = %u（thereinto state spend %u，explore spend %u，eyeshot spend %u，area spend %u）\n",
			pCEnt->GetLogName(), dwAllTime, tMoveState.GetTimeCount(), tMoveMMask.GetTimeCount(), tMoveEyeshot.GetTimeCount(), tMoveArea.GetTimeCount());
T_E}

void SubMap::LoadMonsterInfo(void)
{T_B
T_E}

// 重置地表状态
void SubMap::ClearSurfaceState(void)
{T_B
	CStateCell		*pCStateCell;
	m_CStateCellL.BeginGet();
	while (pCStateCell = m_CStateCellL.GetNext())
	{
		pCStateCell->DropState(this);
	}
T_E}

// 复位非玩家角色，用于副本重新开启时的角色初始化
void SubMap::ResetNotPlyCha()
{T_B
	CCharacter	*pCCha;
	Long		lChaCount, lChaNum;
	CEyeshotCell	*pCEyeCell;
	for (Short y = 0; y < GetEyeshotCellLin(); y++)
	{
		for (Short x = 0; x < GetEyeshotCellCol(); x++)
		{
			pCEyeCell = &m_pCEyeshotCell[y][x];
			lChaCount = 0;
			lChaNum = pCEyeCell->GetChaNum();
			pCCha = pCEyeCell->m_pCChaL;

			while (pCCha)
			{
				if (++lChaCount > lChaNum)
				{
					//LG("视野激活错误", "视野单元[%d,%d]实际实体数 %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
					LG("eyeshot activation error", "eyeshot cell[%d,%d] practice entity numbers%d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
					break;
				}

				if (!pCCha->IsPlayerOwnCha())
					pCCha->Reset();

				if (pCCha->m_pCEyeshotCellNext)
					pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
				else
					pCCha = 0;
			}
		}
	}
T_E}

// 驱除玩家角色，用于副本关闭时，所有玩家角色出副本
void SubMap::ClearPlayerCha()
{T_B
	CEyeshotCell	*pCEyeCell;
	CCharacter		*pCCha, *pCProcCha;
	long			lChaCount, lChaNum;
	//LG("enter_map", "地图 %s（副本号 %d），开始清除所有玩家!\n", GetName(), GetCopyNO());
	LG("enter_map", "map %s(copyID %d),start delete all character!\n", GetName(), GetCopyNO());
	m_CEyeshotCellL.BeginGet();
	while (pCEyeCell = m_CEyeshotCellL.GetNext())
	{
		lChaCount = 0;
		lChaNum = pCEyeCell->GetChaNum();
		pCCha = pCEyeCell->m_pCChaL;
		while (pCCha)
		{
			if (++lChaCount > lChaNum)
			{
				//LG("视野激活错误", "视野单元[%d,%d]实际实体数 %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
				LG("eyeshot activation error", "eyeshot cell[%d,%d]practice entity numbers %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
				break;
			}

			pCProcCha = pCCha;
			if (pCCha->m_pCEyeshotCellNext)
				pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
			else
				pCCha = 0;

			if(pCProcCha->IsPlayerFocusCha())
			{
				if (!pCProcCha->GetSubMap())
					//LG("视野激活错误", "在进行地图通告时玩家 %s(%s)[%d,%d] 的地图为空\n",
					LG("eyeshot activation error", "in the wind map notify character %s(%s)[%d,%d] 's map is empty\n",
						pCProcCha->GetLogName(), pCProcCha->GetPlyCtrlCha()->GetLogName(), pCProcCha->GetPos().x, pCProcCha->GetPos().y);

				//LG("enter_map", "地图 %s 关闭，清除玩家 %s[%s]!\n", GetName(), pCProcCha->GetName(), pCProcCha->GetPlyMainCha()->GetName());
				LG("enter_map", "map %s close，clean out %s[%s]!\n", GetName(), pCProcCha->GetName(), pCProcCha->GetPlyMainCha()->GetName());
				if (!pCProcCha->IsLiveing())
				{
					g_CParser.DoString("Relive", enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, pCProcCha, DOSTRING_PARAM_END);

					pCProcCha->m_chSelRelive = enumEPLAYER_RELIVE_NONE;
					pCProcCha->m_chReliveLv = 0;
					pCProcCha->BackToCityEx(true);
				}
				else
					pCProcCha->BackToCityEx();
			}
		}
	}
	m_COutMapCha.Drop();
	//LG("enter_map", "地图 %s（副本号 %d） 清除玩家成功!\n", GetName(), GetCopyNO());
	LG("enter_map", "map %s( copyID %d)clean out character succeed!\n", GetName(), GetCopyNO());
T_E}

void SubMap::ClearAllMonster(void)
{T_B
	CCharacter	*pCCha;
	Long		lChaCount, lChaNum;
	CEyeshotCell	*pCEyeCell;
	for (Short y = 0; y < GetEyeshotCellLin(); y++)
	{
		for (Short x = 0; x < GetEyeshotCellCol(); x++)
		{
			pCEyeCell = &m_pCEyeshotCell[y][x];
			lChaCount = 0;
			lChaNum = pCEyeCell->GetChaNum();
			pCCha = pCEyeCell->m_pCChaL;

			while (pCCha)
			{
				if (++lChaCount > lChaNum)
				{
					//LG("视野激活错误", "视野单元[%d,%d]实际实体数 %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
					LG("eyeshot activation error", "eyeshot cell[%d,%d]practice entity number %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
					break;
				}

				if (!pCCha->IsPlayerOwnCha())
					pCCha->ResetLifeTime(1000);

				if (pCCha->m_pCEyeshotCellNext)
					pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
				else
					pCCha = 0;
			}
		}
	}
T_E}

void SubMap::ClearAllMonsterByName(const char* szMonsName)
{T_B
	CCharacter	*pCCha;
	Long		lChaCount, lChaNum;
	CEyeshotCell	*pCEyeCell;
	for (Short y = 0; y < GetEyeshotCellLin(); y++)
	{
		for (Short x = 0; x < GetEyeshotCellCol(); x++)
		{
			pCEyeCell = &m_pCEyeshotCell[y][x];
			lChaCount = 0;
			lChaNum = pCEyeCell->GetChaNum();
			pCCha = pCEyeCell->m_pCChaL;

			while (pCCha)
			{
				if (++lChaCount > lChaNum)
				{
					//LG("视野激活错误", "视野单元[%d,%d]实际实体数 %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
					LG("eyeshot activation error", "eyeshot cell[%d,%d]practice entity number %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
					break;
				}

				if (!pCCha->IsPlayerOwnCha())
				{
					if (!strcmp(pCCha->GetName(), szMonsName))
						pCCha->ResetLifeTime(1000);
				}

				if (pCCha->m_pCEyeshotCellNext)
					pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
				else
					pCCha = 0;
			}
		}
	}
T_E}

void SubMap::ClearAllCha()
{T_B
	CEyeshotCell	*pCEyeCell;
	CCharacter		*pCCha, *pCProcCha;
	long			lChaCount, lChaNum;
	//LG("enter_map", "地图 %s（副本号 %d），开始清除所有怪物!\n", GetName(), GetCopyNO());
	LG("enter_map", "map %s(copyID %d)，start clean out all monsters\n", GetName(), GetCopyNO());
	m_CEyeshotCellL.BeginGet();
	while (pCEyeCell = m_CEyeshotCellL.GetNext())
	{
		lChaCount = 0;
		lChaNum = pCEyeCell->GetChaNum();
		pCCha = pCEyeCell->m_pCChaL;
		while (pCCha)
		{
			if (++lChaCount > lChaNum)
			{
				//LG("视野激活错误", "视野单元[%d,%d]实际实体数 %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
				LG("eyeshot activation error", "eyeshot cell[%d,%d]practice entity numbers %d\n", pCEyeCell->m_sPosX, pCEyeCell->m_sPosY, lChaNum);
				break;
			}

			pCProcCha = pCCha;
			if (pCCha->m_pCEyeshotCellNext)
				pCCha = pCCha->m_pCEyeshotCellNext->IsCharacter();
			else
				pCCha = 0;

			if(!pCProcCha->IsPlayerFocusCha())
			{
				pCProcCha->Free();
			}
			else
			{
				if (!pCProcCha->GetSubMap())
					//LG("视野激活错误", "在进行地图通告时玩家 %s(%s)[%d,%d] 的地图为空\n",
					LG("eyeshot activation error", "in the wind map notify character %s(%s)[%d,%d] 's map is empty\n",
					pCProcCha->GetLogName(), pCProcCha->GetPlyCtrlCha()->GetLogName(), pCProcCha->GetPos().x, pCProcCha->GetPos().y);

				//LG("enter_map", "地图 %s 关闭，清除玩家 %s[%s]!\n", GetName(), pCProcCha->GetName(), pCProcCha->GetPlyMainCha()->GetName());
				LG("enter_map", "map %s close,clean out character %s[%s]!\n", GetName(), pCProcCha->GetName(), pCProcCha->GetPlyMainCha()->GetName());
				if (!pCProcCha->IsLiveing())
				{
					g_CParser.DoString("Relive", enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, pCProcCha, DOSTRING_PARAM_END);

					pCProcCha->m_chSelRelive = enumEPLAYER_RELIVE_NONE;
					pCProcCha->m_chReliveLv = 0;
					pCProcCha->BackToCityEx(true);
				}
				else
					pCProcCha->BackToCityEx();
			}
		}
		pCEyeCell->m_pCChaL = NULL;
	}
	//LG("enter_map", "地图 %s（副本号 %d） 清除怪物成功!\n", GetName(), GetCopyNO());
	LG("enter_map", "map %s(copyID %d)clean out monster succeed!\n", GetName(), GetCopyNO());
T_E}

void SubMap::EntryOpen()
{T_B
	Open();
T_E}

void SubMap::EntryClose()
{T_B
T_E}

void SubMap::Open()
{T_B
	if (m_bIsRun)
		return;

	m_bIsRun = true;
T_E}

void SubMap::Run(DWORD dwCurTime)
{T_B
	if (!m_bIsRun)
		return;

	m_COutMapCha.Run(dwCurTime);

	// 1秒钟
	if (m_timeScriptRun.IsOK(dwCurTime))
	{
		string	strScript = "map_copy_run_";
		strScript += GetName();
		g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, this, DOSTRING_PARAM_END);
	}

	// 5分钟
	if (m_timeSpecialRun.IsOK(dwCurTime))
	{
		string	strScript = "map_copy_run_special_";
		strScript += GetName();
		g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, this, DOSTRING_PARAM_END);

	}

T_E}

void SubMap::Close()
{T_B
	if (!m_bIsRun)
		return;
	string	strScript = "map_copy_before_close_";
	strScript += GetName();
	g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, this, DOSTRING_PARAM_END);

	ClearSurfaceState();

	ClearPlayerCha();
	m_COutMapCha.Drop();
	ResetNotPlyCha();

	strScript = "map_copy_close_";
	strScript += GetName();
	g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, this, DOSTRING_PARAM_END);

	m_bIsRun = false;
T_E}

void SubMap::BeforePlyOutMap(CCharacter *pCCha)
{T_B
	m_pCMapRes->SubEntryPlayer(GetCopyNO());

	string	strScript = "before_leave_";
	strScript += GetName();
	g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 2, pCCha, this, DOSTRING_PARAM_END);
T_E}

void SubMap::AfterPlyEnterMap(CCharacter *pCCha)
{T_B
	string	strScript = "after_enter_";
	strScript += GetName();
	g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 2, pCCha, this, DOSTRING_PARAM_END);
T_E}

void SubMap::BeginGetPlyCha(void)
{T_B
	m_CEyeshotCellL.BeginGet();
	CEyeshotCell	*pCEyeCell = m_CEyeshotCellL.GetCurrent();
	if (pCEyeCell)
		pCEyeCell->BeginGetCha();
T_E}

CCharacter* SubMap::GetNextPlyCha(void)
{T_B
	CCharacter	*pCCha = 0;

Research:
	CEyeshotCell	*pCEyeCell = m_CEyeshotCellL.GetCurrent();
	if (pCEyeCell)
	{
		pCCha = pCEyeCell->GetNextCha();
		while (!pCCha)
		{
			m_CEyeshotCellL.GetNext();
			pCEyeCell = m_CEyeshotCellL.GetCurrent();
			if (!pCEyeCell)
				break;
			pCEyeCell->BeginGetCha();
			pCCha = pCEyeCell->GetNextCha();
		}
	}
	if (pCCha)
		if (!pCCha->IsPlayerOwnCha())
			goto Research;

	return pCCha;
T_E}

bool SubMap::CheckRun(void)
{T_B
	if (IsRun())
		return true;
	if (!m_pCMapRes)
		return false;

	if (m_pCMapRes->GetCopyStartType() == enumMAPCOPY_START_CONDITION)
	{
		if (m_pCMapRes->GetCopyStartCdtType() == enumMAPCOPY_START_CDT_PLYNUM)
		{
			if (GetPlayerNum() >= m_pCMapRes->GetCopyStartCdtVal())
			{
				Open();

				string	strScript = "map_copy_first_run_";
				strScript += GetName();
				g_CParser.DoString(strScript.c_str(), enumSCRIPT_RETURN_NONE, 0, enumSCRIPT_PARAM_LIGHTUSERDATA, 1, this, DOSTRING_PARAM_END);

				return true;
			}
		}
	}

	return false;
T_E}

void SubMap::DealActivePlayer(string& function)
{T_B
	CCharacter * pCha;
	BeginGetPlyCha();

	while(pCha = GetNextPlyCha())
	{
		if(pCha->IsPlayerCha() && pCha->IsLiveing())
		{
			g_CParser.DoString(function.c_str(),enumSCRIPT_RETURN_NONE, 0,enumSCRIPT_PARAM_LIGHTUSERDATA, 1,pCha,DOSTRING_PARAM_END);
		}
	}
	

T_E}

void SubMap::DealPlayer(string& function)
{T_B
	CCharacter * pCha = NULL;
	BeginGetPlyCha();

	while(pCha = GetNextPlyCha())
	{
		if(pCha->IsPlayerCha())
		{
			g_CParser.DoString(function.c_str(),enumSCRIPT_RETURN_NONE, 0,enumSCRIPT_PARAM_LIGHTUSERDATA, 1,pCha,DOSTRING_PARAM_END);
		}
	}
T_E}

//=============================================================================
COutMapCha::COutMapCha(unsigned short usFreq)
{T_B
	m_ulTick = GetTickCount();
	m_usFreq = usFreq;
	m_pSExecQueue = NULL;
	m_pSFreeQueue = NULL;
T_E}

COutMapCha::~COutMapCha()
{T_B
	SMgrUnit	*pSCarrier;

	pSCarrier = m_pSExecQueue;
	while (pSCarrier)
	{
		m_pSExecQueue = pSCarrier->pSNext;
		delete pSCarrier;
		pSCarrier = m_pSExecQueue;
	}

	pSCarrier = m_pSFreeQueue;
	while (pSCarrier)
	{
		m_pSFreeQueue = pSCarrier->pSNext;
		delete pSCarrier;
		pSCarrier = m_pSFreeQueue;
	}
T_E}

void COutMapCha::Add(CCharacter *pCObj, dbc::uLong	ulChaID, SSwitchMapInfo *pSwitchInfo, Char chAction, Long lLeftTick1, Long lLeftTick2)
{T_B
	if (!pCObj)
		return;

	SMgrUnit	*pSCarrier = NULL;

	if (m_pSFreeQueue) // 有空闲的载体
	{
		pSCarrier = m_pSFreeQueue;
		m_pSFreeQueue = pSCarrier->pSNext;
	}
	else // 分配新的载体
	{
		pSCarrier = new SMgrUnit;
		if (!pSCarrier)
		{
			//THROW_EXCP(excpMem, "区域状态管理对象构造过程中分配内存失败");
			THROW_EXCP(excpMem, RES_STRING(GM_SUBMAP_CPP_00006));
		}
	}

	// 设置数据并将之加入执行队列
	pSCarrier->pCCha = pCObj;
	pSCarrier->ulChaID = ulChaID;
	memcpy(&pSCarrier->SwitchInfo, pSwitchInfo, sizeof(SSwitchMapInfo));
	pSCarrier->chAction = chAction;
	pSCarrier->lLeftTick1 = lLeftTick1;
	pSCarrier->lLeftTick2 = lLeftTick2;
	pSCarrier->chStep = 1;

	pSCarrier->pSNext = m_pSExecQueue;
	m_pSExecQueue = pSCarrier;
T_E}

void COutMapCha::Run(unsigned long ulCurTick)
{T_B
	long	lTickDist = ulCurTick - m_ulTick;

	if (lTickDist < m_usFreq)
		return;
	m_ulTick = ulCurTick;

	bool		bDrop;
	SMgrUnit	*pSCarrier, *pSLastCarrier;
	pSCarrier = pSLastCarrier = m_pSExecQueue;
	while (pSCarrier)
	{
		if (!pSCarrier->IsValidCha()) // 角色已经无效
		{
			// 从执行队列中脱链
			if (pSCarrier == m_pSExecQueue)
			{
				m_pSExecQueue = pSCarrier->pSNext;

				pSCarrier->pSNext = m_pSFreeQueue;
				m_pSFreeQueue = pSCarrier;

				pSLastCarrier = m_pSExecQueue;
				pSCarrier = pSLastCarrier;
			}
			else
			{
				pSLastCarrier->pSNext = pSCarrier->pSNext;

				pSCarrier->pSNext = m_pSFreeQueue;
				m_pSFreeQueue = pSCarrier;

				pSCarrier = pSLastCarrier->pSNext;
			}
			continue;
		}

		bDrop = false;

		if (pSCarrier->chStep == 1)
		{
			pSCarrier->lLeftTick1 -= lTickDist;
			if (pSCarrier->lLeftTick1 <= 0)
				ExecTimeCha(pSCarrier);
		}
		else if (pSCarrier->chStep == 2)
		{
			pSCarrier->lLeftTick2 -= lTickDist;
			if (pSCarrier->lLeftTick2 <= 0)
				bDrop = true;
		}

		if (!bDrop)
		{
			pSLastCarrier = pSCarrier;
			pSCarrier = pSCarrier->pSNext;
		}
		else // 载体的计时完成
		{
			ExecTimeCha(pSCarrier);
			// 从执行队列中脱链
			if (pSCarrier == m_pSExecQueue)
			{
				m_pSExecQueue = pSCarrier->pSNext;

				pSCarrier->pSNext = m_pSFreeQueue;
				m_pSFreeQueue = pSCarrier;

				pSLastCarrier = m_pSExecQueue;
				pSCarrier = pSLastCarrier;
			}
			else
			{
				pSLastCarrier->pSNext = pSCarrier->pSNext;

				pSCarrier->pSNext = m_pSFreeQueue;
				m_pSFreeQueue = pSCarrier;

				pSCarrier = pSLastCarrier->pSNext;
			}
		}
	}
T_E}

void COutMapCha::Drop()
{T_B
	SMgrUnit	*pSCarrier, *pSLastCarrier;
	pSCarrier = pSLastCarrier = m_pSExecQueue;
	while (pSCarrier)
	{
		// 载体的计时完成
		{
			ExecTimeCha(pSCarrier);
			ExecTimeCha(pSCarrier);
			// 从执行队列中脱链
			if (pSCarrier == m_pSExecQueue)
			{
				m_pSExecQueue = pSCarrier->pSNext;

				pSCarrier->pSNext = m_pSFreeQueue;
				m_pSFreeQueue = pSCarrier;

				pSLastCarrier = m_pSExecQueue;
				pSCarrier = pSLastCarrier;
			}
			else
			{
				pSLastCarrier->pSNext = pSCarrier->pSNext;

				pSCarrier->pSNext = m_pSFreeQueue;
				m_pSFreeQueue = pSCarrier;

				pSCarrier = pSLastCarrier->pSNext;
			}
		}
	}
T_E}

void COutMapCha::ExecTimeCha(SMgrUnit *pChaInfo)
{T_B
	if (pChaInfo->chStep == 1)
	{
		pChaInfo->SwitchInfo.pSrcMap->GoOut(pChaInfo->pCCha);
		pChaInfo->pCCha->SetExistState(enumEXISTS_RESUMEING);
		pChaInfo->chStep++;
	}
	else if (pChaInfo->chStep == 2)
	{
		switch (pChaInfo->chAction)
		{
		case	enumCHA_TIMEER_ENTERMAP:
			{
				CCharacter	*pCCha = pChaInfo->pCCha;
				if (pCCha->IsPlayerCha()) // 不应该出现的情况
				{
					//LG("怪物重生错误", "怪物名称 %s，玩家角色名称 %s(%s)\n", pCCha->GetLogName(), pCCha->GetPlyMainCha()->GetLogName(), pCCha->GetPlyCtrlCha()->GetLogName());
					LG("monster renascence errror", "monster name %s，character player name %s(%s)\n", pCCha->GetLogName(), pCCha->GetPlyMainCha()->GetLogName(), pCCha->GetPlyCtrlCha()->GetLogName());
					break;
				}
				
				// 非玩家角色如果设置了生命时间, 则不会重生
				if(pCCha->GetLifeTime()!=0)
				{
					break;
				}

				pCCha->SetInOutMapQueue(false);
				pCCha->m_chSelRelive = enumEPLAYER_RELIVE_NONE;

				g_ulCurID = pCCha->GetID();
				g_lCurHandle = pCCha->GetHandle();

				pCCha->setAttr(ATTR_HP, pCCha->m_CChaAttr.GetAttr(ATTR_MXHP));	// 当前HP
				pCCha->setAttr(ATTR_SP, pCCha->m_CChaAttr.GetAttr(ATTR_MXSP));	// 当前SP
				//pCCha->m_timerScripts.Reset();
				pCCha->SetExistState(enumEXISTS_NATALITY);
				pCCha->SwitchMap(pChaInfo->SwitchInfo.pSrcMap, pChaInfo->SwitchInfo.szTarMapName, pChaInfo->SwitchInfo.STarPos.x, pChaInfo->SwitchInfo.STarPos.y, false, enumSWITCHMAP_DIE, pChaInfo->SwitchInfo.pSrcMap->GetCopyNO());

				pCCha->ResetAIState();	// 重设ai所需的状态记录

				g_ulCurID = defINVALID_CHA_ID;
				g_lCurHandle = defINVALID_CHA_HANDLE;
			}
			break;
		}
		pChaInfo->chStep++;
	}
T_E}

